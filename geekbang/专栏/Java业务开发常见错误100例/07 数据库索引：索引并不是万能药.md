一、 InnoDB是如何存储数据的？
1. Mysql存储引擎InnoDB数据虽然保存在磁盘中，但其处理是在内存中进行的。为了减少磁盘随机读取次数，InnoDB采用页而不是行的粒度来保存数据，即数据被分成若干页，以页为单位保存在磁盘中。InnoDB的页大小一般为16KB；
2. 各个数据页组成一个双向链表，每个数据页中的记录按照主键顺序组成单向链表；每一个数据页中有一个页目录，方便按照主键查询记录。
![MysqlInnoDB数据页结构](https://github.com/hujiapeng/imgs/blob/master/geekbang/Java%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF100%E4%BE%8B/MysqlInnoDB%E6%95%B0%E6%8D%AE%E9%A1%B5%E7%BB%93%E6%9E%84.jpg?raw=true)
3. 页目录通过槽把记录分成不同的小组，每个小组有若干条记录。记录中最前面的小方块中的数字，代表的是当前分组的记录条数，最小和最大的槽指向2个特殊的伪记录，最小记录和最大记录。
4. 有了槽之后，就可以采用二分法，按照主键搜索页中记录，无需遍历整个页中的记录链表

二、聚簇索引和二级索引
1. 页目录就是最简单的索引，通过对记录进行一级分组来降低搜索的时间复杂度，但这样能够降低的时间复杂度非常有限。那就需要考虑如何创建合适的索引，来方便定位记录所在页，InnoDB引入B+树来解决这个问题，B+树是一棵倒过来的树。
![B+树](https://github.com/hujiapeng/imgs/blob/master/geekbang/Java%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF100%E4%BE%8B/B+%E6%A0%91.jpg?raw=true)
2. InnoDB使用B+树既可以保存实际数据，也可以加速数据搜索，这就是聚簇索引。由于数据在物里上只会保存一份，所以包含实际数据的聚簇索引只能有一个。B+树特点：
 - 最底层的节点叫作叶子节点，用来存放数据
 - 其他上层节点叫作非叶子节点，仅用来存放目录项，作为索引
 - 非叶子节点分为不同层次，通过分层来降低每一层的搜索量
 - 所有节点按照索引键大小排序，构成一个双向链表，加速范围查找

3. InnoDB会自动使用主键作为聚簇索引的索引键(如果没有主键，就选择第一个不包含NULL值的唯一列)。B+树就是通过二分查找页目录，找到最终记录。
4. 为了实现非主键的快速索引，就引出了二级索引，也叫非聚簇索引、辅助索引。二级索引也是利用B+树的数据结构，只是二级索引的叶子节点保存的不是实际数剧，而是主键，获得主键后就去聚簇索引中获得数据行，这个过程叫作回表。

三、考虑额外创建二级索引的代价
1. 首先是维护代价：创建N个二级索引就需要再创建N棵B+树，新增数据时不仅药修改聚簇索引，还需要修改这N个二级索引
2. 其次是空间代价：虽然二级索引不保存原始数据，但要保存索引列的数据，所以会占用更多空间。如果select查询的就是索引列，那就不用回表了
3. 最后是回表的代价：二级索引不保存原始数据，通过索引找到主键后需要再查询聚簇索引，才能得到想要的数据。
 - 查看当前Mysql版本命令
    ```
    select version();
    ```
 - 创建表索引
    ```
    create index name_score on person(name,score);
    create index create_time on person(create_time);
    ```
 - 创建表索引如果出错```Specified key was too long; max key length is 767 bytes ```，执行如下命令
    ```
    set global innodb_large_prefix=on;
    set global innodb_file_format=Barracuda;
    ALTER TABLE person ROW_FORMAT=DYNAMIC;
    ```
 - 执行存储过程时报错```The user specified as a definer ('root'@'%') does not exist ```，则执行如下命令
    ```
    grant all privileges on *.* to root@"%" identified by ".";
    flush privileges;
    ```
 - 使用explain命令查看SQL执行计划
    ```
    explain select * from person where name='name1';
    ```
    - key字段代表实际走的是哪个索引
    - type字段代表了访问表的方式，其值为ref说明是二级索引等值匹配
    - extra字段如果有Using index，说明这次查询的是二级索引，没有回表。如select name 就不用回表。
 - 如果要查询的数据是索引列索引或联合索引能覆盖的数据，那么查询索引本身已经"覆盖"了需要的数据，不再需要回表查询，这种情况叫作索引覆盖

4. 总结下索引开销最佳实践：
 - 无需一开始就建立索引，可以等业务明确后或者数据量超过1万、查询变慢后，再针对需要查询、排序或分组的字段创建索引
 - 尽量索引轻量级字段，比如能索引int字段就不要索引varchar字段。索引字段也可以是部分前缀，在创建索引的时候指定字段索引长度。针对长文本搜索，建议使用Elasticsearch等专门文本搜索的索引数据库
 - 尽量不要在SQL中使用select * ，而是select必要字段，甚至可以考虑使用联合索引来包含要搜索的字段，既能实现索引加速，又可以避免回表的开销

四、不是所有针对索引列的查询都能用上索引
1. 索引只能匹配前缀
 - 如执行SQL ```explain select * from person where name like 'name1%' limit 100; ```看到type为range表示走索引扫描，key字段看到走了对应索引。如果like语句后面的条件为```%name1 ```，那么type字段值会为ALL，代表全表扫描。如果去掉limit，```like 'name1%' ```就不会走索引了，这个是数据库基于成本决定是否走索引
 - 索引B+树中的数据按照索引值排序，只能根据前缀进行比较；如果想按照后缀搜索也走索引的话，那可以将数据反过来存储

2. 条件涉及函数操作无法走索引。如执行SQL```explain select * from person where length(name)=7; ```，type字段值为ALL。索引保存的是索引列的原始数据，不是经过函数计算后的值。如果想要针对函数调用走索引，那只能保存一份函数变换后的值(新加一列)，然后对这一计算列做索引
3. 联合索引只能匹配左边的列。对于多个列构成的索引，数据是按照索引第一列排序，第一列数据相同时才会按照第二列排序。where子句中列字段位置不会影响索引查询，因为有查询优化器对SQL语句进行优化。(连接器、查询缓存、分析器、优化器、执行器)

五、数据库基于成本决定是否走索引
1. Mysql在查询数据前，会先对可能的方案做执行计划，然后依据成本决定走哪个执行计划(IO成本和CPU成本)
 - IO成本，是从磁盘把数据加载到内存的成本。默认情况下，读取数据页的IO成本常数是1(也就是读取1个数据页成本是1);
 - CPU成本，是检测数据是否满足条件和排序等CPU操作的成本。默认情况下，检测记录的成本是0.2

2. Mysql并不是实时统计成本信息的，而是靠一个维护统计信息的表，所以这种成本计算是一种估算。查询某表统计信息的SQL为```show table status like 'person'; ```。
 - 执行后可看到Rows，总行数，乘以0.2后就是CPU成本
 - 根据InnoDB每个页大小为16KB，使用上述命令查到的Data_length除以16*1000可估算出页面数，乘以1就是IO成本

3. 如果想强制使用索引，可以如下操作
   ```
   EXPLAIN SELECT * FROM person FORCE INDEX(name_score) WHERE NAME >'name84059' AND create_time>'2020-01-24 05:00:00' 
   ```