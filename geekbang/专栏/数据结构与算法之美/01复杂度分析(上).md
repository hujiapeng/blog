1. 数据结构和算法本身解决的是“快”和“省”的问题，即如何让代码运行的更快，更省空间。执行效率是算法重要的考量指标，而时间、空间复杂度是算法代码执行效率的考量指标。
2. 代码运行一遍，通过统计、监控等手段就能得到算法执行时间和占用内存大小，为什么还要做时间和空间复杂度分析？这种方法常被称作事后统计法，有很大局限性:
   - 测试结果非常依赖测试环境，如服务器CPU及内存等硬件环境差异；
   - 测试结果受数据规模的影响很大，测试数据规模大小及数据的有序度差异；
3. 时间、空间复杂度分析法可以让我们不需要测试数据，粗略估计算法执行效率。
4. 大O复杂度表示法:
   - 算法执行效率粗俗讲就是代码执行时间。尽管每行代码对应的CPU执行个数和时间都不一样，但我们可以粗略的估计为每行代码执行时间一样，为unit_time，所有代码执行时间T(n)与每行代码执行次数成正比。
   - T(n)=O(f(n))，T(n)表示代码执行时间，n表示数据规模大小，f(n)表示每行代码执行次数总和，O表示代码执行时间T(n)与表达式f(n)成正比。
   - 大O时间复杂度实际上并不具体表示代码真正的执行时间，而表示代码执行时间随数据规模增长的变化趋势，所以也叫渐进时间复杂度，简称时间复杂度。如果用大O表示法表示时间复杂度，我们只记录一个最大量级，去掉公式中的低阶、常量、系数三部分，因为这三部分并不左右增长趋势。表示法如T(n)=O(n)或T(n) = O(n^2)。
5. 时间复杂度的三个分析方法:
   - 只关注循环执行次数最多的一段代码。
   - 加法法则，总复杂度等于量级最大的那段代码的复杂度。公式如下
     如果 T1(n)=O(f(n))，T2(n)=O(g(n))；那么 T(n)=T1(n)+T2(n)=max(O(f(n)), O(g(n))) =O(max(f(n), g(n)))。
   - 乘法法则，嵌套代码的复杂度等于嵌套内外代码的复杂度乘积。
     如果 T1(n)=O(f(n))，T2(n)=O(g(n))；那么 T(n)=T1(n)*T2(n)=O(f(n))*O(g(n))=O(f(n)*g(n))。
6. 时间复杂度量级分为多项式量级和非多项式量级两类，非多项式量级只有两个:O(2^n) 和 O(n!)。我们把时间复杂度为非多项式量级的算法问题叫作NP(Non-Deterministic Polynomial，非确定多项式)问题。当随着数据规模增大，非多项式量级算法的执行时间会急剧增加，是非常低效的算法。因此NP问题不再讨论。
7. 常见的多项式时间复杂度如:

   - O(1)，一般情况只要代码中不存在循环或递归，即使有成千上万行代码，时间复杂度也是O(1)。
   - O(logn)、O(nlogn)，对数阶时间复杂度，由于对数可以互相转换，大O表示对数阶时间复杂度时忽略对数“底”，统一表示为O(logn)。根据乘法法则，如果一段代码的时间复杂度为O(logn)，循环执行n遍，时间复杂度就是O(nlogn)。
   - O(m+n)、O(m*n)，代码中存在两种数据规模的代码段平行关系运行，无嵌套，无法评估谁的量级大，这种情况下就不能简单利用加法法则了，要写成O(m+n)，针对这种情况的加法法则要改为T1(m) + T2(n) = O(f(m) + g(n))。如果代码中两种数据规模代码是嵌套式的，那么乘法法则继续有效：T1(m)*T2(n) = O(f(m) * f(n))。

   <img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1594016303642.png" alt="1594016303642" style="zoom:50%;" />
   <img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1594017072648.png" alt="1594017072648" style="zoom:50%;" />
8. 空间复杂度，全称是渐进式空间复杂度，表示算法的存储空间与数据规模之间的增长关系。我们常见的空间复杂度就是 O(1)、O(n)、O(n^2)，像 O(logn)、O(nlogn) 这样的对数阶复杂度平时都用不到。