一、应用架构演进过程
单体应用：
1. JEE时期：把企业软件划分为展示层、业务逻辑层和数据存储层。
 - 优点：分工明确、职责清晰，衍生出前端团队、后端团队和DBA团队；开发简单，所有的类都直接本地使用，事务处理只需要依赖数据库即可。由于企业内部用户使用，不用考虑高并发等场景，加上JEE稳定性，基本能满足日常需求
 - 缺点：大多数应用都在一个JVM中，随着应用的增大，性能会不断下降；业务之间耦合严重，即使企业有严格规范，随着业务逻辑复杂度增加，开发人员流动，整个应用会变得维护越来越困难；EJB使用大量XML作为配置文件，后期要配置出一个服务的学习成本高。各种各样的规范约束加大了开发者的开发成本

2. MVC框架时期：常见的有SSH和SSM框架组合，随着时间推移，Spring家族蓬勃发展，成为现在应用的必备框架之一
 - 优点：分层更加简单，框架更加轻量级，开发效率有了很大提升，单元测试方面也更加完善
 - 缺点：应用还是会被打到一个War包里，部署在Web服务器里，系统的耦合度依然没有太大改善；后期很多企业对应用做垂直拆分，把业务上没有关联的系统独立出来，形成独立对外提供服务的系统，但此时的系统服务间完全独立，不能远程调用，基础代码不能复用

分布式应用
1. 早期SOA：面向服务的架构(SOA)，将单一进程的应用做了拆分，形成独立对外提供服务的组件，每个组件通过网络协议对外提供服务。常见的SOA实现方式有两种：WebService和ESB。特点如下
 - 明确的协议：服务之间的交互都通过特定的协议进行
 - 明确的接口：根据规则划分出不同的服务，每个服务都有明确的对外接口。这让服务的复用成为可能
 - 合作方式的改变：后端团队会根据不同的服务进一步拆分，有了更加细化的分工与合作方式
 - 通信方式：初期的通信方式通常为XML，由于XML有大量冗余信息，后来被JSON取代

2. 微服务化：微服务架构中，一个应用被拆分成一个个独立、可配置、可运行、可维护的子服务，极大的方便了服务复用，通过不同的服务编排方式，快速产生新的业务逻辑。微服务与SOA区别：
 - 目的不同：ESB更加强调业务流程的编排，历史应用的集成。而微服务使用一系列微小的服务来实现整体流程，可以有效地拆分服务，从而实现敏捷的部署与交付
 - 服务粒度不同：微服务拆分得更加细小，从而可以方便的复用服务，编排出新的业务逻辑。SOA通常是比较粗粒度的划分
 - 协议的不同：微服务通常都是统一的交互协议，如HTTP、自定义的协议，兼容老系统比较困难

3. 云原生
 - 容量动态规划：微服务出现后，服务容量的评估、小服务资源的浪费等问题逐渐显现。为了实现资源的动态规划，容器化逐渐成为标配，容器编排技术也逐步走向成熟。
 - 服务框架的臃肿：应用虽然已经微服务化，但应用中包含大量业务无关的资源库，即使开发一个小服务也要带上一个臃肿的框架。为了让应用变得更加轻量，下沉更多的通用能力，服务网格开始出现

Dubbo简介
1. Dubbo是阿里SOA服务化治理方案的核心框架，提供了注册中心机制，解耦了消费方和服务方动态发现的问题，并提供高可靠能力，大量采用微内核+富插件设计思想，包括框架自身核心特性都作为扩展点实现，提供灵活的可扩展能力
![](https://raw.githubusercontent.com/hujiapeng/imgs/master/readingnotes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ApacheDubbo%E4%B8%8E%E5%AE%9E%E6%88%98/01Dubbo-%E9%AB%98%E6%80%A7%E8%83%BDRPC%E9%80%9A%E4%BF%A1%E6%A1%86%E6%9E%B6/Dubbo%E7%9A%84%E6%9E%B6%E6%9E%84.jpg)
图中，Provider启动时会向注册中心把自己的元数据注册上去(比如服务IP和端口等)，Consumer在启动时会从注册中心订阅(第一次订阅会拉取全量数据)服务提供方的元数据，注册中心发生数据变更会推送给订阅的Consumer。在获取服务元数据后，Consumer可以发起RPC调用，在RPC调用前后会向监控中心上报统计信息(比如并发数和调用的接口)
2. Dubbo特性：
 - 面向接口代理的高性能RPC调用：提供高性能的基于代理的远程调用能力，服务以接口为粒度，为开发者屏蔽远程调用底层细节
 - 服务自动注册与发现：支持多种注册中心服务，服务实例上下线实时感知
 - 运行期流量调度：内置条件、脚本等路由策略，通过配置不同路由规则，轻松实现灰度发布、同机房优先等功能
 - 智能负载均衡：内置多种负载均衡策略，智能感知下游节点健康状况，显著减少调用延迟，提高系统吞吐量
 - 高度可扩展能力：遵循微内核+插件的设计思想，所有核心能力如Protocol、Transport、Serialization被设计为扩展点，平等对待内置实现和第三方实现
 - 可视化的服务治理与运维：提供丰富服务治理、运维工具；随时查询服务元数据、服务健康状态及调用统计，实时下发路由策略、调整配置参数

3. Dubbo总体分层：总体分为三层，每一层再细分分为十层，**业务层**(Biz)，包括Service；**RPC层**，包括Config(主要接口：CongfigParser)、Proxy(主要接口：ProxyFactory)、Registry(主要接口：Registry、RegistryFactory、RegistryService)、Cluster(主要接口：Cluster、Directory、LoadBalance)、Monitor(主要接口：Monitor、MonitorFactory、MonitorService)、Protocol(主要接口：Protocol、Invoker、Exporter)；**Remoting层**，包括Exchange(主要接口：Exchanger、ExchangeChannel、ExchangeClient、ExchangeServer)、Transport(主要接口：Codec、Transporter、ChannelHandler、Server/Client)、Serialize(主要接口：ObjectOutput、Serialization、ObjectInput)
 - Service：业务层。包括业务代码接口与实现，即开发者实现的业务代码
 - Config：配置层。管理了整个Dubbo的配置。主要围绕ServiceConfig(暴露的服务配置)和ReferenceConfig(引用的服务配置)两个实现类展开，初始化配置信息
 - Proxy：服务代理层。在Dubbo中，无论生产者还是消费者，框架都会生成一个代理类，整个过程对上层是透明的。当调用一个远程接口时，看起来就像是调用了一个本地的接口一样，代理层会自动做远程调用并返回结果，即让业务层对远程调用完全无感
 - Registry：注册层。负责Dubbo框架的服务注册与发现。当有新的服务加入或旧的服务下线时，注册中心都会感知并通知给所有订阅方。整个过程无需人工参与
 - Cluster：集群容错层。该层主要负责，远程调用失败时的容错策略(如失败重试、快速失败)；选择具体调用节点时的负载均衡策略(如随机、一致性Hash等)；特殊调用路径的路由策略(如某个消费者只会调用某个IP的生产者)
 - Monitor：监控层。主要负责监控统计调用次数和调用时间等
 - Protocol：远程调用层。远程调用层。封装RPC调用具体过程，Protocol是Invoker暴露(发布一个服务让别人可以调用)和引用(引用一个远程服务到本地)的主功能入口，负责管理Invoker的整个生命周期。Invoker是Dubbo的核心模型，框架中所有其他模型都向它靠拢，或者转换成它，它代表一个可执行体。允许向它发起invoke调用，它可能是执行一个本地方法的接口实现，也可能是一个远程的实现，还可能是一个集群实现
 - Exchange：信息交换层。把网络传输抽象为统一的接口，如Mina和Netty虽然接口不一样，但是Dubbo在它们上面又封装了统一接口。用户也可根据其扩展接口添加更多网络传输方式
 - Serialize：序列化层。如果数据要通过网络进行发送，则需要先做序列化，变成二进制流。序列化层负责管理整个框架网络传输时的序列化/反序列化工作

4. Dubbo总体调用过程
 - 服务端(服务提供者)整个接口暴露过程：首先，服务器端(服务提供者)在框架启动时，会初始化服务实例，通过Proxy组件调用具体协议(Protocol)，把服务端要暴露的接口封装成Invoker(真实类型是AbstractProxyInvoker)，然后转换成Exporter，这个时候框架会打开服务端口等并记录服务实例到内存中，最后通过Registry把服务元数据注册到注册中心。
 - 消费者调用服务提供者流程：
 ![](https://raw.githubusercontent.com/hujiapeng/imgs/master/readingnotes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ApacheDubbo%E4%B8%8E%E5%AE%9E%E6%88%98/01Dubbo-%E9%AB%98%E6%80%A7%E8%83%BDRPC%E9%80%9A%E4%BF%A1%E6%A1%86%E6%9E%B6/Dubbo%E7%BB%84%E4%BB%B6%E8%B0%83%E7%94%A8%E6%80%BB%E4%BD%93%E6%B5%81%E7%A8%8B.jpg)
 首先，调用过程也是从一个Proxy开始的，Proxy持有了一个Invoker对象。然后触发invoke调用。在invoke调用过程中，需要使用Cluster，Cluster负责容错，如调用失败的重试。Cluster在调用之前会通过Directory获取所有可以调用的远程服务Invoker列表(一个接口可能有多个节点提供服务)。由于可以调用的远程服务有很多，此时如果用户配置了路由规则(如指定某些方法只能调用某个节点)，那么还会根据路由规则将Invoker列表过滤一遍。
 然后，存活下来的Invoker可能还会有很多，此时要调用哪一个，会通过LoadBalance方法做负载均衡，最终选出一个可以调用的Invoker。这个Invoker在调用之前会经过一个过滤链，这个过滤链通常是处理上下文、限流、计数等。
 接着，会使用Client做数据传输，如我们常见的Netty Client等。传输之前肯定要做一些私有协议的构造，此时就会用到Codec接口。构造完成后，就对数据包做序列化(Serialization)，然后传输到服务提供者端。服务提供者收到数据包，也会使用Codec处理协议头及一些半包、粘包等。处理完成后再对完整的数据报文做反序列化处理。
 随后，这个Request会被分配到线程池(ThreadPool)中进行处理。Server会处理这些Request，根据请求查找对应的Exporter(它内部持有了Invoker)。Invoker是被用装饰器模式一层一层套了非常多Filter的，因此在调用最终的实现类之前，又会经过一个服务提供者端的过滤器链。
 最终，我们得到了具体接口的真实实现并调用，再原路把结果返回。