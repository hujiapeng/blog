1. 内存布局
Java8及其之后版本彻底移除了持久代，而使用Metaspace来代替，也就是表示-XX:PermSize和-XX:MaxPermSize等参数调优就没有意义了。JVM内存区域说明如下：
 - JVM堆中的数据是共享的，是占用内存最大的一块区域；
 - JVM内存中与多线程相关的有，程序运行中用到的Java虚拟机栈和本地方法栈，以及线程切换中用到的程序计数器；
 - 本地内存包含元数据区(包含方法区)和一些直接内存；
 - 执行字节码的模块叫作执行引擎。

2. 虚拟机栈
Java虚拟机栈是基于线程的，在线程的生命周期中，参与计算的数据会频繁地入栈和出栈。栈里的每条数据就是栈帧，在Java方法被调用的时候，都会创建一个栈帧，并入栈。一旦完成相应的调用就出栈。每个栈帧都包含四个区域：局部变量表、操作数栈、动态链接、返回地址。其中返回地址，即returnAddress类型的值是指向特定指令内存地址的指针。
Java虚拟机栈对应着两层栈。第一层就是对应着方法的栈帧，即调用方法时创建的栈帧；第二层就是方法执行时，对应着操作数的栈。所有字节码指令都会抽象成对栈的入栈和出栈操作，执行引擎只需要傻瓜式的按顺序执行即可。
3. 程序计数器
线程的运行是靠CPU分配时间片的，所以JVM需要对线程正在运行的点位进行缓冲记录，以便在获取CPU时间片时能够快速恢复。程序计数器的作用可以看作是当前线程所执行的字节码的行号指示器，这里面存的就是当前线程执行的进度。程序计数器与虚拟机栈配合完成计算操作。程序计数器还存储了当前正在运行的流程，包括正在执行的指令、跳转、分支、循环、异常处理等。使用javap命令输出的字节码中，可以看到每个opcode前面都有一个序号。
4. 堆
JVM垃圾回收操作的对象就是堆。GC不仅仅是销毁对象，还要对堆空间进行整理，避免被许多细小碎片占满，造成空间浪费。
创建的对象是分配在堆上还是栈上，这和对象的类型与对象(基本数据类型对象)在Java类中的位置有关。对于普通对象来说，JVM会首先在堆上创建对象，然后其他地方使用的其实是它的引用；对于基本数据类型(byte、short、int、long、float、double、char)来说，如果是在方法体内声明的，那么就会直接在栈上分配，其他情况就会在堆上分配。注意，像int[]这样的基本类型的数组并不是基本类型，而是引用类型。
5. 元空间
Java中类像是一个模板，定义了一系列属性和操作；而由类创建的对象，更像一个活生生的个体，可以参与到程序的运行中。
Java8之前这些类信息放在一个叫Perm区的内存里(JVM堆内存中)，这个区域有大小限制，很容易造成OOM导致JVM奔溃。Java８及其之后，Perm区被废除，取而代之的是Metaspace，即元空间，是在非堆上。元空间直接使用内存，这样虽然降低了JVM堆的使用率，不会出现方法区内存溢出，但是无限制的使用会造成操作系统的死亡。所以，一般也会使用参数-XX:MaxMetaspaceSize来控制大小。
方法区存储的内容包括，类的信息、常量池、方法数据和方法代码，就存储在Metaspace中。