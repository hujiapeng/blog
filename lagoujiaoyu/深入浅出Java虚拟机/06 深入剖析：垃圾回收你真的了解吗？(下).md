1. CMS简介
 - Minor GC：发生在年轻的GC；
 - Major GC：发生在老年代的GC；
 - Full GC：全堆垃圾回收。比如Metaspace区引起年轻代和老年代的回收。

 CMS全称Mostly Concurrent Mark and Sweep Garbage Collector，并发标记清除垃圾收集器，它的年轻代使用复制算法，而对老年代使用标记-清除算法。CMS设计目标是避免老年代GC时出现长时间的卡顿。
 CMS使用的Sweep而不是Compact，所以它的主要问题是碎片化。随着JVM运行，碎片化越来越严重，只有通过Full GC才能完成整理。CMS获得更小的停顿时间，主要是因为最耗时的一些操作，做成了和应用线程并行。
2. CMS回收过程
 - 初始标记(Initial Mark)：初始标记阶段，只标记直接关联GC Root的对象，不用向下追溯。因为最耗时的就在tracing阶段，这样就极大地缩短了初始标记的时间。这个过程是STW的，但是由于只是标记第一层，即只标记root对象，还要标记年轻代中对象引用，这个速度是很快的。CMS虽然是老年代垃圾收集器，但依然会扫描新生代。
 - 并发标记(Concurrent Mark)：初始标记完成后，就进行并发标记。这一步主要是tracing过程，用于标记可达对象。这个过程会持续很长时间，但却可以和用户线程并行。这个阶段执行过程中，可能会产生很多变化，如下：
    - 有些对象从新生代晋升到老年代；
    - 有些对象直接分配到了老年代；
    - 老年代和新生代对象引用发生了变化。 
    
    在这个阶段，受到影响的老年代对象对应的卡页，会被标记为dirty，用于后续重新标记阶段的扫描。
 - 并发预清理(Concurrent Preclean)：这个过程是非STW的，目的是让重新标记阶段的STW尽可能短。这个阶段，老年代中被标记为dirty的卡页中的对象，就会被重新标记，然后清除掉dirty的状态。由于这个阶段也是可以并发的，执行过程中，对象引用关系依然会发生变化，重新标记阶段，有可能还会有处于dirty状态的卡页。可以认为并发预清理是这个清理动作的第一次清理。
 - 并发可取消的预清理(Concurrent Abortable Preclean)：这个阶段是可选的，可以理解为“并发预清理”阶段的一种优化。这个阶段的第一个意图，是避免回扫年轻代的大量对象；另一个意图，就是当满足最终标记的条件时，自动退出。
 由于重新标记是需要STW的，所以会有很多次预清理动作。当满足某些条件时，可以终止。如并发预清理阶段的标记动作是需要扫描年轻代的，如果年轻代对象太多，肯定会严重影响标记时间。CMS提供了参数CMSScavengeBeforeRemark，可以在进入重新标记之前强制进行一次Minor GC。注意，如果不是很了解这些参数，不要去修改。如果CMS使用了参数CMSScavengeBeforeRemark，那么可能会在一个较长的Minor GC后，紧跟着一个CMS的Remark，这两个阶段都是STW的。
 - 最终标记(Final Remark)：通常CMS会尝试在年轻代尽可能空的情况下运行Final Remark阶段，以免接连多次发生STW事件。这时CMS垃圾回收阶段的第二次STW，目标是完成老年代中所有存活对象的标记。前面的多轮preclean阶段，有可能跟不上引用变化速度。最终标记就需要STW来处理了。所以预处理阶段如果做得不够好，那就会增加本阶段的STW时间。
 - 并发清除(Concurrent Sweep)：此阶段用户线程重新激活，即STW结束，目标是删掉不可达对象，并回收它们的空间。由于是并行，所以还会有新的垃圾产生，只能到下次GC时清理，这部分垃圾称为“浮动垃圾”。
 - 并发重置(Concurrent Reset)：此阶段与应用程序并发执行，重置CMS算法相关内部数据，为下一次GC做准备。

3. 内存碎片
 由于CMS在执行过程中，用户线程还需要运行，那就需要保证有充足的内存空间供用户使用。如果等老年代空间快满了，再开启这个回收过程，用户线程可能会产生"Concurrent Mode Failure"错误，这时会临时启用Serial Old收集器来重新进行老年代垃圾收集，这个过程是STW的，停顿时间很长。
 这部分空间预留，一般在30%左右即可，也就是能用的空间只有70%。可通过参数-XX:CMSInitiatingOccupancyFraction配置这个比例，记得首先开启参数UseInitiatingOccupancyOnly。也就是说当老年代使用率到70%，就会触发GC了。如果系统老年代增长不快，可以调高这个参数，降低内存回收次数。
 CMS对老年代回收的时候，并没有内存整理阶段。所以长时间运行后，碎片太多。CMS提供两个参数来解决这个问题：
 - UseCMSCompactAtFullCollection(默认开启)，表示在要进行Full GC的时候，进行内存碎片整理。内存整理的过程是无法并发的，是STW的。
 - CMSFullGCsBeforeCompaction每隔多少次不压缩的Full GC后，执行一次带压缩的Full GC。默认为0，表示每次进入Full GC时，都进行碎片整理。

 所以预留空间和内存碎片，使用CMS垃圾回收器的老年代，剩余的空间就不多了，这也是CMS的一个弱点。
4. 小结：
 CMS回收器的四个阶段：
   - 初始标记
   - 并发标记
   - 重新标记
   - 并发清理

 CMS中STW阶段：
   - 初始标记，这部分停顿时间短；
   - Minor GC，在预处理阶段对年轻代的回收，停顿由年轻代决定；
   - 重新标记，由于有preclean阶段，所以这部分停顿时间也短；
   - Serial-Old收集老年代的停顿，主要发生在预留空间不足情况下，时间会持续很长；
   - Full GC，会整理内存，持续时间较长。

 发生GC问题时可以通过gclog查看详细过程。
 CMS优势：低延迟，尤其对于大堆来说。大部分垃圾回收过程并发执行。
 CMS劣势：
   - 内存碎片问题，Full GC整理阶段，造成长时间停顿；
   - 需要预留空间，用来分配收集阶段产生的"浮动垃圾"；
   - 使用更多的CPU资源，在应用运行的同时进行堆扫描。
   
 由于G1和ZGC的产生，CMS已经在废弃的路上了。